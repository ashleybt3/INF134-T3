{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[63],{\"8Mb5\":function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,\"ion_virtual_scroll\",function(){return VirtualScroll});var _index_7a8b7a1c_js__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"wEJo\"),_helpers_dd7e4b7b_js__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(\"1vRN\");const createNode=(el,type)=>{const template=getTemplate(el,type);return template&&el.ownerDocument?el.ownerDocument.importNode(template.content,!0).children[0]:null},getTemplate=(el,type)=>{switch(type){case\"item\":return el.querySelector(\"template:not([name])\");case\"header\":return el.querySelector(\"template[name=header]\");case\"footer\":return el.querySelector(\"template[name=footer]\")}},calcCells=(items,itemHeight,headerHeight,footerHeight,headerFn,footerFn,approxHeaderHeight,approxFooterHeight,approxItemHeight,j,offset,len)=>{const cells=[],end=len+offset;for(let i=offset;i<end;i++){const item=items[i];if(headerFn){const value=headerFn(item,i,items);null!=value&&cells.push({i:j++,type:\"header\",value:value,index:i,height:headerHeight?headerHeight(value,i):approxHeaderHeight,reads:headerHeight?0:2,visible:!!headerHeight})}if(cells.push({i:j++,type:\"item\",value:item,index:i,height:itemHeight?itemHeight(item,i):approxItemHeight,reads:itemHeight?0:2,visible:!!itemHeight}),footerFn){const value=footerFn(item,i,items);null!=value&&cells.push({i:j++,type:\"footer\",value:value,index:i,height:footerHeight?footerHeight(value,i):approxFooterHeight,reads:footerHeight?0:2,visible:!!footerHeight})}}return cells},VirtualScroll=class{constructor(hostRef){Object(_index_7a8b7a1c_js__WEBPACK_IMPORTED_MODULE_0__.o)(this,hostRef),this.range={offset:0,length:0},this.viewportHeight=0,this.cells=[],this.virtualDom=[],this.isEnabled=!1,this.viewportOffset=0,this.currentScrollTop=0,this.indexDirty=0,this.lastItemLen=0,this.totalHeight=0,this.approxItemHeight=45,this.approxHeaderHeight=30,this.approxFooterHeight=30,this.onScroll=()=>{this.updateVirtualScroll()}}itemsChanged(){this.calcCells(),this.updateVirtualScroll()}async connectedCallback(){const contentEl=this.el.closest(\"ion-content\");contentEl?(this.scrollEl=await contentEl.getScrollElement(),this.contentEl=contentEl,this.calcCells(),this.updateState()):console.error(\"<ion-virtual-scroll> must be used inside an <ion-content>\")}componentDidUpdate(){this.updateState()}disconnectedCallback(){this.scrollEl=void 0}onResize(){this.calcCells(),this.updateVirtualScroll()}positionForItem(index){return Promise.resolve(((index,cells,heightIndex)=>{const cell=cells.find(c=>\"item\"===c.type&&c.index===index);return cell?heightIndex[cell.i]:-1})(index,this.cells,this.getHeightIndex()))}async checkRange(offset,len=-1){if(!this.items)return;const length=-1===len?this.items.length-offset:len,cellIndex=((cells,index)=>0===index?0:index===(cells.length>0?cells[cells.length-1].index:0)+1?cells.length:cells.findIndex(c=>c.index===index))(this.cells,offset),cells=calcCells(this.items,this.itemHeight,this.headerHeight,this.footerHeight,this.headerFn,this.footerFn,this.approxHeaderHeight,this.approxFooterHeight,this.approxItemHeight,cellIndex,offset,length);this.cells=((dst,src,offset)=>{if(0===offset&&src.length>=dst.length)return src;for(let i=0;i<src.length;i++)dst[i+offset]=src[i];return dst})(this.cells,cells,cellIndex),this.lastItemLen=this.items.length,this.indexDirty=Math.max(offset-1,0),this.scheduleUpdate()}async checkEnd(){this.items&&this.checkRange(this.lastItemLen)}updateVirtualScroll(){this.isEnabled&&this.scrollEl&&(this.timerUpdate&&(clearTimeout(this.timerUpdate),this.timerUpdate=void 0),Object(_index_7a8b7a1c_js__WEBPACK_IMPORTED_MODULE_0__.h)(this.readVS.bind(this)),Object(_index_7a8b7a1c_js__WEBPACK_IMPORTED_MODULE_0__.f)(this.writeVS.bind(this)))}readVS(){const{contentEl:contentEl,scrollEl:scrollEl,el:el}=this;let topOffset=0,node=el;for(;node&&node!==contentEl;)topOffset+=node.offsetTop,node=node.offsetParent;this.viewportOffset=topOffset,scrollEl&&(this.viewportHeight=scrollEl.offsetHeight,this.currentScrollTop=scrollEl.scrollTop)}writeVS(){const dirtyIndex=this.indexDirty,viewport=(scrollTop=this.currentScrollTop-this.viewportOffset,vierportHeight=this.viewportHeight,{top:Math.max(scrollTop-100,0),bottom:scrollTop+vierportHeight+100}),heightIndex=this.getHeightIndex(),range=((heightIndex,viewport,buffer)=>{const topPos=viewport.top,bottomPos=viewport.bottom;let i=0;for(;i<heightIndex.length&&!(heightIndex[i]>topPos);i++);const offset=Math.max(i-2-1,0);for(;i<heightIndex.length&&!(heightIndex[i]>=bottomPos);i++);return{offset:offset,length:Math.min(i+2,heightIndex.length)-offset}})(heightIndex,viewport);var scrollTop,vierportHeight;((dirtyIndex,currentRange,range)=>dirtyIndex<=range.offset+range.length||currentRange.offset!==range.offset||currentRange.length!==range.length)(dirtyIndex,this.range,range)&&(this.range=range,((dom,heightIndex,cells,range)=>{for(const node of dom)node.change=0,node.d=!0;const toMutate=[],end=range.offset+range.length;for(let i=range.offset;i<end;i++){const cell=cells[i],node=dom.find(n=>n.d&&n.cell===cell);if(node){const top=heightIndex[i];top!==node.top&&(node.top=top,node.change=1),node.d=!1}else toMutate.push(cell)}const pool=dom.filter(n=>n.d);for(const cell of toMutate){const node=pool.find(n=>n.d&&n.cell.type===cell.type),index=cell.i;node?(node.d=!1,node.change=2,node.cell=cell,node.top=heightIndex[index]):dom.push({d:!1,cell:cell,visible:!0,change:2,top:heightIndex[index]})}dom.filter(n=>n.d&&-9999!==n.top).forEach(n=>{n.change=1,n.top=-9999})})(this.virtualDom,heightIndex,this.cells,range),this.nodeRender?((el,nodeRender,dom,updateCellHeight)=>{const children=Array.from(el.children).filter(n=>\"TEMPLATE\"!==n.tagName),childrenNu=children.length;let child;for(let i=0;i<dom.length;i++){const node=dom[i],cell=node.cell;if(2===node.change){if(i<childrenNu)child=children[i],nodeRender(child,cell,i);else{const newChild=createNode(el,cell.type);child=nodeRender(newChild,cell,i)||newChild,child.classList.add(\"virtual-item\"),el.appendChild(child)}child.$ionCell=cell}else child=children[i];0!==node.change&&(child.style.transform=`translate3d(0,${node.top}px,0)`);const visible=cell.visible;node.visible!==visible&&(visible?child.classList.remove(\"virtual-loading\"):child.classList.add(\"virtual-loading\"),node.visible=visible),cell.reads>0&&(updateCellHeight(cell,child),cell.reads--)}})(this.el,this.nodeRender,this.virtualDom,this.updateCellHeight.bind(this)):this.domRender?this.domRender(this.virtualDom):this.renderItem&&Object(_index_7a8b7a1c_js__WEBPACK_IMPORTED_MODULE_0__.l)(this))}updateCellHeight(cell,node){const update=()=>{if(node.$ionCell===cell){const style=window.getComputedStyle(node),height=node.offsetHeight+parseFloat(style.getPropertyValue(\"margin-bottom\"));this.setCellHeight(cell,height)}};node?Object(_helpers_dd7e4b7b_js__WEBPACK_IMPORTED_MODULE_1__.c)(node,update):update()}setCellHeight(cell,height){const index=cell.i;cell===this.cells[index]&&(cell.height===height&&!0===cell.visible||(cell.visible=!0,cell.height=height,this.indexDirty=Math.min(this.indexDirty,index),this.scheduleUpdate()))}scheduleUpdate(){clearTimeout(this.timerUpdate),this.timerUpdate=setTimeout(()=>this.updateVirtualScroll(),100)}updateState(){const shouldEnable=!(!this.scrollEl||!this.cells);shouldEnable!==this.isEnabled&&(this.enableScrollEvents(shouldEnable),shouldEnable&&this.updateVirtualScroll())}calcCells(){this.items&&(this.lastItemLen=this.items.length,this.cells=calcCells(this.items,this.itemHeight,this.headerHeight,this.footerHeight,this.headerFn,this.footerFn,this.approxHeaderHeight,this.approxFooterHeight,this.approxItemHeight,0,0,this.lastItemLen),this.indexDirty=0)}getHeightIndex(){return this.indexDirty!==1/0&&this.calcHeightIndex(this.indexDirty),this.heightIndex}calcHeightIndex(index=0){this.heightIndex=((buf,len)=>{if(!buf)return new Uint32Array(len);if(buf.length===len)return buf;if(len>buf.length){const newBuf=new Uint32Array(len);return newBuf.set(buf),newBuf}return buf.subarray(0,len)})(this.heightIndex,this.cells.length),this.totalHeight=((buf,cells,index)=>{let acum=buf[index];for(let i=index;i<buf.length;i++)buf[i]=acum,acum+=cells[i].height;return acum})(this.heightIndex,this.cells,index),this.indexDirty=1/0}enableScrollEvents(shouldListen){this.rmEvent&&(this.rmEvent(),this.rmEvent=void 0);const scrollEl=this.scrollEl;scrollEl&&(this.isEnabled=shouldListen,scrollEl.addEventListener(\"scroll\",this.onScroll),this.rmEvent=()=>{scrollEl.removeEventListener(\"scroll\",this.onScroll)})}renderVirtualNode(node){const{type:type,value:value,index:index}=node.cell;switch(type){case\"item\":return this.renderItem(value,index);case\"header\":return this.renderHeader(value,index);case\"footer\":return this.renderFooter(value,index)}}render(){return Object(_index_7a8b7a1c_js__WEBPACK_IMPORTED_MODULE_0__.j)(_index_7a8b7a1c_js__WEBPACK_IMPORTED_MODULE_0__.c,{style:{height:`${this.totalHeight}px`}},this.renderItem&&Object(_index_7a8b7a1c_js__WEBPACK_IMPORTED_MODULE_0__.j)(VirtualProxy,{dom:this.virtualDom},this.virtualDom.map(node=>this.renderVirtualNode(node))))}get el(){return Object(_index_7a8b7a1c_js__WEBPACK_IMPORTED_MODULE_0__.k)(this)}static get watchers(){return{itemHeight:[\"itemsChanged\"],headerHeight:[\"itemsChanged\"],footerHeight:[\"itemsChanged\"],items:[\"itemsChanged\"]}}},VirtualProxy=({dom:dom},children,utils)=>utils.map(children,(child,i)=>{const node=dom[i],vattrs=child.vattrs||{};let classes=vattrs.class||\"\";return classes+=\"virtual-item \",node.visible||(classes+=\"virtual-loading\"),Object.assign(Object.assign({},child),{vattrs:Object.assign(Object.assign({},vattrs),{class:classes,style:Object.assign(Object.assign({},vattrs.style),{transform:`translate3d(0,${node.top}px,0)`})})})});VirtualScroll.style=\"ion-virtual-scroll{display:block;position:relative;width:100%;contain:strict;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}ion-virtual-scroll>.virtual-loading{opacity:0}ion-virtual-scroll>.virtual-item{position:absolute !important;top:0 !important;right:0 !important;left:0 !important;-webkit-transition-duration:0ms;transition-duration:0ms;will-change:transform}\"}}]);","name":"63-es2015.fd9c81a9794c6efa3964.js","input":"(window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || []).push([[63],{\n\n/***/ \"8Mb5\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ion_virtual_scroll\", function() { return VirtualScroll; });\n/* harmony import */ var _index_7a8b7a1c_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"wEJo\");\n/* harmony import */ var _helpers_dd7e4b7b_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"1vRN\");\n\n\n\nconst CELL_TYPE_ITEM = 'item';\nconst CELL_TYPE_HEADER = 'header';\nconst CELL_TYPE_FOOTER = 'footer';\nconst NODE_CHANGE_NONE = 0;\nconst NODE_CHANGE_POSITION = 1;\nconst NODE_CHANGE_CELL = 2;\n\nconst MIN_READS = 2;\nconst updateVDom = (dom, heightIndex, cells, range) => {\n  // reset dom\n  for (const node of dom) {\n    node.change = NODE_CHANGE_NONE;\n    node.d = true;\n  }\n  // try to match into exisiting dom\n  const toMutate = [];\n  const end = range.offset + range.length;\n  for (let i = range.offset; i < end; i++) {\n    const cell = cells[i];\n    const node = dom.find(n => n.d && n.cell === cell);\n    if (node) {\n      const top = heightIndex[i];\n      if (top !== node.top) {\n        node.top = top;\n        node.change = NODE_CHANGE_POSITION;\n      }\n      node.d = false;\n    }\n    else {\n      toMutate.push(cell);\n    }\n  }\n  // needs to append\n  const pool = dom.filter(n => n.d);\n  for (const cell of toMutate) {\n    const node = pool.find(n => n.d && n.cell.type === cell.type);\n    const index = cell.i;\n    if (node) {\n      node.d = false;\n      node.change = NODE_CHANGE_CELL;\n      node.cell = cell;\n      node.top = heightIndex[index];\n    }\n    else {\n      dom.push({\n        d: false,\n        cell,\n        visible: true,\n        change: NODE_CHANGE_CELL,\n        top: heightIndex[index],\n      });\n    }\n  }\n  dom\n    .filter(n => n.d && n.top !== -9999)\n    .forEach(n => {\n    n.change = NODE_CHANGE_POSITION;\n    n.top = -9999;\n  });\n};\nconst doRender = (el, nodeRender, dom, updateCellHeight) => {\n  const children = Array.from(el.children).filter(n => n.tagName !== 'TEMPLATE');\n  const childrenNu = children.length;\n  let child;\n  for (let i = 0; i < dom.length; i++) {\n    const node = dom[i];\n    const cell = node.cell;\n    // the cell change, the content must be updated\n    if (node.change === NODE_CHANGE_CELL) {\n      if (i < childrenNu) {\n        child = children[i];\n        nodeRender(child, cell, i);\n      }\n      else {\n        const newChild = createNode(el, cell.type);\n        child = nodeRender(newChild, cell, i) || newChild;\n        child.classList.add('virtual-item');\n        el.appendChild(child);\n      }\n      child['$ionCell'] = cell;\n    }\n    else {\n      child = children[i];\n    }\n    // only update position when it changes\n    if (node.change !== NODE_CHANGE_NONE) {\n      child.style.transform = `translate3d(0,${node.top}px,0)`;\n    }\n    // update visibility\n    const visible = cell.visible;\n    if (node.visible !== visible) {\n      if (visible) {\n        child.classList.remove('virtual-loading');\n      }\n      else {\n        child.classList.add('virtual-loading');\n      }\n      node.visible = visible;\n    }\n    // dynamic height\n    if (cell.reads > 0) {\n      updateCellHeight(cell, child);\n      cell.reads--;\n    }\n  }\n};\nconst createNode = (el, type) => {\n  const template = getTemplate(el, type);\n  if (template && el.ownerDocument) {\n    return el.ownerDocument.importNode(template.content, true).children[0];\n  }\n  return null;\n};\nconst getTemplate = (el, type) => {\n  switch (type) {\n    case CELL_TYPE_ITEM: return el.querySelector('template:not([name])');\n    case CELL_TYPE_HEADER: return el.querySelector('template[name=header]');\n    case CELL_TYPE_FOOTER: return el.querySelector('template[name=footer]');\n  }\n};\nconst getViewport = (scrollTop, vierportHeight, margin) => {\n  return {\n    top: Math.max(scrollTop - margin, 0),\n    bottom: scrollTop + vierportHeight + margin\n  };\n};\nconst getRange = (heightIndex, viewport, buffer) => {\n  const topPos = viewport.top;\n  const bottomPos = viewport.bottom;\n  // find top index\n  let i = 0;\n  for (; i < heightIndex.length; i++) {\n    if (heightIndex[i] > topPos) {\n      break;\n    }\n  }\n  const offset = Math.max(i - buffer - 1, 0);\n  // find bottom index\n  for (; i < heightIndex.length; i++) {\n    if (heightIndex[i] >= bottomPos) {\n      break;\n    }\n  }\n  const end = Math.min(i + buffer, heightIndex.length);\n  const length = end - offset;\n  return { offset, length };\n};\nconst getShouldUpdate = (dirtyIndex, currentRange, range) => {\n  const end = range.offset + range.length;\n  return (dirtyIndex <= end ||\n    currentRange.offset !== range.offset ||\n    currentRange.length !== range.length);\n};\nconst findCellIndex = (cells, index) => {\n  const max = cells.length > 0 ? cells[cells.length - 1].index : 0;\n  if (index === 0) {\n    return 0;\n  }\n  else if (index === max + 1) {\n    return cells.length;\n  }\n  else {\n    return cells.findIndex(c => c.index === index);\n  }\n};\nconst inplaceUpdate = (dst, src, offset) => {\n  if (offset === 0 && src.length >= dst.length) {\n    return src;\n  }\n  for (let i = 0; i < src.length; i++) {\n    dst[i + offset] = src[i];\n  }\n  return dst;\n};\nconst calcCells = (items, itemHeight, headerHeight, footerHeight, headerFn, footerFn, approxHeaderHeight, approxFooterHeight, approxItemHeight, j, offset, len) => {\n  const cells = [];\n  const end = len + offset;\n  for (let i = offset; i < end; i++) {\n    const item = items[i];\n    if (headerFn) {\n      const value = headerFn(item, i, items);\n      if (value != null) {\n        cells.push({\n          i: j++,\n          type: CELL_TYPE_HEADER,\n          value,\n          index: i,\n          height: headerHeight ? headerHeight(value, i) : approxHeaderHeight,\n          reads: headerHeight ? 0 : MIN_READS,\n          visible: !!headerHeight,\n        });\n      }\n    }\n    cells.push({\n      i: j++,\n      type: CELL_TYPE_ITEM,\n      value: item,\n      index: i,\n      height: itemHeight ? itemHeight(item, i) : approxItemHeight,\n      reads: itemHeight ? 0 : MIN_READS,\n      visible: !!itemHeight,\n    });\n    if (footerFn) {\n      const value = footerFn(item, i, items);\n      if (value != null) {\n        cells.push({\n          i: j++,\n          type: CELL_TYPE_FOOTER,\n          value,\n          index: i,\n          height: footerHeight ? footerHeight(value, i) : approxFooterHeight,\n          reads: footerHeight ? 0 : MIN_READS,\n          visible: !!footerHeight,\n        });\n      }\n    }\n  }\n  return cells;\n};\nconst calcHeightIndex = (buf, cells, index) => {\n  let acum = buf[index];\n  for (let i = index; i < buf.length; i++) {\n    buf[i] = acum;\n    acum += cells[i].height;\n  }\n  return acum;\n};\nconst resizeBuffer = (buf, len) => {\n  if (!buf) {\n    return new Uint32Array(len);\n  }\n  if (buf.length === len) {\n    return buf;\n  }\n  else if (len > buf.length) {\n    const newBuf = new Uint32Array(len);\n    newBuf.set(buf);\n    return newBuf;\n  }\n  else {\n    return buf.subarray(0, len);\n  }\n};\nconst positionForIndex = (index, cells, heightIndex) => {\n  const cell = cells.find(c => c.type === CELL_TYPE_ITEM && c.index === index);\n  if (cell) {\n    return heightIndex[cell.i];\n  }\n  return -1;\n};\n\nconst virtualScrollCss = \"ion-virtual-scroll{display:block;position:relative;width:100%;contain:strict;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}ion-virtual-scroll>.virtual-loading{opacity:0}ion-virtual-scroll>.virtual-item{position:absolute !important;top:0 !important;right:0 !important;left:0 !important;-webkit-transition-duration:0ms;transition-duration:0ms;will-change:transform}\";\n\nconst VirtualScroll = class {\n  constructor(hostRef) {\n    Object(_index_7a8b7a1c_js__WEBPACK_IMPORTED_MODULE_0__[/* r */ \"o\"])(this, hostRef);\n    this.range = { offset: 0, length: 0 };\n    this.viewportHeight = 0;\n    this.cells = [];\n    this.virtualDom = [];\n    this.isEnabled = false;\n    this.viewportOffset = 0;\n    this.currentScrollTop = 0;\n    this.indexDirty = 0;\n    this.lastItemLen = 0;\n    this.totalHeight = 0;\n    /**\n     * It is important to provide this\n     * if virtual item height will be significantly larger than the default\n     * The approximate height of each virtual item template's cell.\n     * This dimension is used to help determine how many cells should\n     * be created when initialized, and to help calculate the height of\n     * the scrollable area. This height value can only use `px` units.\n     * Note that the actual rendered size of each cell comes from the\n     * app's CSS, whereas this approximation is used to help calculate\n     * initial dimensions before the item has been rendered.\n     */\n    this.approxItemHeight = 45;\n    /**\n     * The approximate height of each header template's cell.\n     * This dimension is used to help determine how many cells should\n     * be created when initialized, and to help calculate the height of\n     * the scrollable area. This height value can only use `px` units.\n     * Note that the actual rendered size of each cell comes from the\n     * app's CSS, whereas this approximation is used to help calculate\n     * initial dimensions before the item has been rendered.\n     */\n    this.approxHeaderHeight = 30;\n    /**\n     * The approximate width of each footer template's cell.\n     * This dimension is used to help determine how many cells should\n     * be created when initialized, and to help calculate the height of\n     * the scrollable area. This height value can only use `px` units.\n     * Note that the actual rendered size of each cell comes from the\n     * app's CSS, whereas this approximation is used to help calculate\n     * initial dimensions before the item has been rendered.\n     */\n    this.approxFooterHeight = 30;\n    this.onScroll = () => {\n      this.updateVirtualScroll();\n    };\n  }\n  itemsChanged() {\n    this.calcCells();\n    this.updateVirtualScroll();\n  }\n  async connectedCallback() {\n    const contentEl = this.el.closest('ion-content');\n    if (!contentEl) {\n      console.error('<ion-virtual-scroll> must be used inside an <ion-content>');\n      return;\n    }\n    this.scrollEl = await contentEl.getScrollElement();\n    this.contentEl = contentEl;\n    this.calcCells();\n    this.updateState();\n  }\n  componentDidUpdate() {\n    this.updateState();\n  }\n  disconnectedCallback() {\n    this.scrollEl = undefined;\n  }\n  onResize() {\n    this.calcCells();\n    this.updateVirtualScroll();\n  }\n  /**\n   * Returns the position of the virtual item at the given index.\n   */\n  positionForItem(index) {\n    return Promise.resolve(positionForIndex(index, this.cells, this.getHeightIndex()));\n  }\n  /**\n   * This method marks a subset of items as dirty, so they can be re-rendered. Items should be marked as\n   * dirty any time the content or their style changes.\n   *\n   * The subset of items to be updated can are specifing by an offset and a length.\n   */\n  async checkRange(offset, len = -1) {\n    // TODO: kind of hacky how we do in-place updated of the cells\n    // array. this part needs a complete refactor\n    if (!this.items) {\n      return;\n    }\n    const length = (len === -1)\n      ? this.items.length - offset\n      : len;\n    const cellIndex = findCellIndex(this.cells, offset);\n    const cells = calcCells(this.items, this.itemHeight, this.headerHeight, this.footerHeight, this.headerFn, this.footerFn, this.approxHeaderHeight, this.approxFooterHeight, this.approxItemHeight, cellIndex, offset, length);\n    this.cells = inplaceUpdate(this.cells, cells, cellIndex);\n    this.lastItemLen = this.items.length;\n    this.indexDirty = Math.max(offset - 1, 0);\n    this.scheduleUpdate();\n  }\n  /**\n   * This method marks the tail the items array as dirty, so they can be re-rendered.\n   *\n   * It's equivalent to calling:\n   *\n   * ```js\n   * virtualScroll.checkRange(lastItemLen);\n   * ```\n   */\n  async checkEnd() {\n    if (this.items) {\n      this.checkRange(this.lastItemLen);\n    }\n  }\n  updateVirtualScroll() {\n    // do nothing if virtual-scroll is disabled\n    if (!this.isEnabled || !this.scrollEl) {\n      return;\n    }\n    // unschedule future updates\n    if (this.timerUpdate) {\n      clearTimeout(this.timerUpdate);\n      this.timerUpdate = undefined;\n    }\n    // schedule DOM operations into the stencil queue\n    Object(_index_7a8b7a1c_js__WEBPACK_IMPORTED_MODULE_0__[/* f */ \"h\"])(this.readVS.bind(this));\n    Object(_index_7a8b7a1c_js__WEBPACK_IMPORTED_MODULE_0__[/* c */ \"f\"])(this.writeVS.bind(this));\n  }\n  readVS() {\n    const { contentEl, scrollEl, el } = this;\n    let topOffset = 0;\n    let node = el;\n    while (node && node !== contentEl) {\n      topOffset += node.offsetTop;\n      node = node.offsetParent;\n    }\n    this.viewportOffset = topOffset;\n    if (scrollEl) {\n      this.viewportHeight = scrollEl.offsetHeight;\n      this.currentScrollTop = scrollEl.scrollTop;\n    }\n  }\n  writeVS() {\n    const dirtyIndex = this.indexDirty;\n    // get visible viewport\n    const scrollTop = this.currentScrollTop - this.viewportOffset;\n    const viewport = getViewport(scrollTop, this.viewportHeight, 100);\n    // compute lazily the height index\n    const heightIndex = this.getHeightIndex();\n    // get array bounds of visible cells base in the viewport\n    const range = getRange(heightIndex, viewport, 2);\n    // fast path, do nothing\n    const shouldUpdate = getShouldUpdate(dirtyIndex, this.range, range);\n    if (!shouldUpdate) {\n      return;\n    }\n    this.range = range;\n    // in place mutation of the virtual DOM\n    updateVDom(this.virtualDom, heightIndex, this.cells, range);\n    // Write DOM\n    // Different code paths taken depending of the render API used\n    if (this.nodeRender) {\n      doRender(this.el, this.nodeRender, this.virtualDom, this.updateCellHeight.bind(this));\n    }\n    else if (this.domRender) {\n      this.domRender(this.virtualDom);\n    }\n    else if (this.renderItem) {\n      Object(_index_7a8b7a1c_js__WEBPACK_IMPORTED_MODULE_0__[/* j */ \"l\"])(this);\n    }\n  }\n  updateCellHeight(cell, node) {\n    const update = () => {\n      if (node['$ionCell'] === cell) {\n        const style = window.getComputedStyle(node);\n        const height = node.offsetHeight + parseFloat(style.getPropertyValue('margin-bottom'));\n        this.setCellHeight(cell, height);\n      }\n    };\n    if (node) {\n      Object(_helpers_dd7e4b7b_js__WEBPACK_IMPORTED_MODULE_1__[\"c\"])(node, update);\n    }\n    else {\n      update();\n    }\n  }\n  setCellHeight(cell, height) {\n    const index = cell.i;\n    // the cell might changed since the height update was scheduled\n    if (cell !== this.cells[index]) {\n      return;\n    }\n    if (cell.height !== height || cell.visible !== true) {\n      cell.visible = true;\n      cell.height = height;\n      this.indexDirty = Math.min(this.indexDirty, index);\n      this.scheduleUpdate();\n    }\n  }\n  scheduleUpdate() {\n    clearTimeout(this.timerUpdate);\n    this.timerUpdate = setTimeout(() => this.updateVirtualScroll(), 100);\n  }\n  updateState() {\n    const shouldEnable = !!(this.scrollEl &&\n      this.cells);\n    if (shouldEnable !== this.isEnabled) {\n      this.enableScrollEvents(shouldEnable);\n      if (shouldEnable) {\n        this.updateVirtualScroll();\n      }\n    }\n  }\n  calcCells() {\n    if (!this.items) {\n      return;\n    }\n    this.lastItemLen = this.items.length;\n    this.cells = calcCells(this.items, this.itemHeight, this.headerHeight, this.footerHeight, this.headerFn, this.footerFn, this.approxHeaderHeight, this.approxFooterHeight, this.approxItemHeight, 0, 0, this.lastItemLen);\n    this.indexDirty = 0;\n  }\n  getHeightIndex() {\n    if (this.indexDirty !== Infinity) {\n      this.calcHeightIndex(this.indexDirty);\n    }\n    return this.heightIndex;\n  }\n  calcHeightIndex(index = 0) {\n    // TODO: optimize, we don't need to calculate all the cells\n    this.heightIndex = resizeBuffer(this.heightIndex, this.cells.length);\n    this.totalHeight = calcHeightIndex(this.heightIndex, this.cells, index);\n    this.indexDirty = Infinity;\n  }\n  enableScrollEvents(shouldListen) {\n    if (this.rmEvent) {\n      this.rmEvent();\n      this.rmEvent = undefined;\n    }\n    const scrollEl = this.scrollEl;\n    if (scrollEl) {\n      this.isEnabled = shouldListen;\n      scrollEl.addEventListener('scroll', this.onScroll);\n      this.rmEvent = () => {\n        scrollEl.removeEventListener('scroll', this.onScroll);\n      };\n    }\n  }\n  renderVirtualNode(node) {\n    const { type, value, index } = node.cell;\n    switch (type) {\n      case CELL_TYPE_ITEM: return this.renderItem(value, index);\n      case CELL_TYPE_HEADER: return this.renderHeader(value, index);\n      case CELL_TYPE_FOOTER: return this.renderFooter(value, index);\n    }\n  }\n  render() {\n    return (Object(_index_7a8b7a1c_js__WEBPACK_IMPORTED_MODULE_0__[/* h */ \"j\"])(_index_7a8b7a1c_js__WEBPACK_IMPORTED_MODULE_0__[/* H */ \"c\"], { style: {\n        height: `${this.totalHeight}px`\n      } }, this.renderItem && (Object(_index_7a8b7a1c_js__WEBPACK_IMPORTED_MODULE_0__[/* h */ \"j\"])(VirtualProxy, { dom: this.virtualDom }, this.virtualDom.map(node => this.renderVirtualNode(node))))));\n  }\n  get el() { return Object(_index_7a8b7a1c_js__WEBPACK_IMPORTED_MODULE_0__[/* i */ \"k\"])(this); }\n  static get watchers() { return {\n    \"itemHeight\": [\"itemsChanged\"],\n    \"headerHeight\": [\"itemsChanged\"],\n    \"footerHeight\": [\"itemsChanged\"],\n    \"items\": [\"itemsChanged\"]\n  }; }\n};\nconst VirtualProxy = ({ dom }, children, utils) => {\n  return utils.map(children, (child, i) => {\n    const node = dom[i];\n    const vattrs = child.vattrs || {};\n    let classes = vattrs.class || '';\n    classes += 'virtual-item ';\n    if (!node.visible) {\n      classes += 'virtual-loading';\n    }\n    return Object.assign(Object.assign({}, child), { vattrs: Object.assign(Object.assign({}, vattrs), { class: classes, style: Object.assign(Object.assign({}, vattrs.style), { transform: `translate3d(0,${node.top}px,0)` }) }) });\n  });\n};\nVirtualScroll.style = virtualScrollCss;\n\n\n\n\n/***/ })\n\n}]);","inputSourceMap":null}