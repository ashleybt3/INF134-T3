{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[63],{nGaW:function(e,t,n){\"use strict\";n.r(t),n.d(t,\"KEYBOARD_DID_CLOSE\",function(){return o}),n.d(t,\"KEYBOARD_DID_OPEN\",function(){return i}),n.d(t,\"copyVisualViewport\",function(){return l}),n.d(t,\"keyboardDidClose\",function(){return b}),n.d(t,\"keyboardDidOpen\",function(){return p}),n.d(t,\"keyboardDidResize\",function(){return w}),n.d(t,\"resetKeyboardAssist\",function(){return a}),n.d(t,\"setKeyboardClose\",function(){return f}),n.d(t,\"setKeyboardOpen\",function(){return c}),n.d(t,\"startKeyboardAssist\",function(){return u}),n.d(t,\"trackViewportChanges\",function(){return D});const i=\"ionKeyboardDidShow\",o=\"ionKeyboardDidHide\";let r={},d={},s=!1;const a=()=>{r={},d={},s=!1},u=e=>{h(e),e.visualViewport&&(d=l(e.visualViewport),e.visualViewport.onresize=()=>{D(e),p()||w(e)?c(e):b(e)&&f(e)})},h=e=>{e.addEventListener(\"keyboardDidShow\",t=>c(e,t)),e.addEventListener(\"keyboardDidHide\",()=>f(e))},c=(e,t)=>{g(e,t),s=!0},f=e=>{y(e),s=!1},p=()=>!s&&r.width===d.width&&(r.height-d.height)*d.scale>150,w=e=>s&&!b(e),b=e=>s&&d.height===e.innerHeight,g=(e,t)=>{const n=new CustomEvent(i,{detail:{keyboardHeight:t?t.keyboardHeight:e.innerHeight-d.height}});e.dispatchEvent(n)},y=e=>{const t=new CustomEvent(o);e.dispatchEvent(t)},D=e=>{r=Object.assign({},d),d=l(e.visualViewport)},l=e=>({width:Math.round(e.width),height:Math.round(e.height),offsetTop:e.offsetTop,offsetLeft:e.offsetLeft,pageTop:e.pageTop,pageLeft:e.pageLeft,scale:e.scale})}}]);","name":"63.657c5830b559bb10aa1f.js","input":"(window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || []).push([[63],{\n\n/***/ \"nGaW\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"KEYBOARD_DID_CLOSE\", function() { return KEYBOARD_DID_CLOSE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"KEYBOARD_DID_OPEN\", function() { return KEYBOARD_DID_OPEN; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"copyVisualViewport\", function() { return copyVisualViewport; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"keyboardDidClose\", function() { return keyboardDidClose; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"keyboardDidOpen\", function() { return keyboardDidOpen; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"keyboardDidResize\", function() { return keyboardDidResize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"resetKeyboardAssist\", function() { return resetKeyboardAssist; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setKeyboardClose\", function() { return setKeyboardClose; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setKeyboardOpen\", function() { return setKeyboardOpen; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"startKeyboardAssist\", function() { return startKeyboardAssist; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"trackViewportChanges\", function() { return trackViewportChanges; });\nconst KEYBOARD_DID_OPEN = 'ionKeyboardDidShow';\nconst KEYBOARD_DID_CLOSE = 'ionKeyboardDidHide';\nconst KEYBOARD_THRESHOLD = 150;\nlet previousVisualViewport = {};\nlet currentVisualViewport = {};\nlet keyboardOpen = false;\n/**\n * This is only used for tests\n */\nconst resetKeyboardAssist = () => {\n  previousVisualViewport = {};\n  currentVisualViewport = {};\n  keyboardOpen = false;\n};\nconst startKeyboardAssist = (win) => {\n  startNativeListeners(win);\n  if (!win.visualViewport) {\n    return;\n  }\n  currentVisualViewport = copyVisualViewport(win.visualViewport);\n  win.visualViewport.onresize = () => {\n    trackViewportChanges(win);\n    if (keyboardDidOpen() || keyboardDidResize(win)) {\n      setKeyboardOpen(win);\n    }\n    else if (keyboardDidClose(win)) {\n      setKeyboardClose(win);\n    }\n  };\n};\n/**\n * Listen for events fired by native keyboard plugin\n * in Capacitor/Cordova so devs only need to listen\n * in one place.\n */\nconst startNativeListeners = (win) => {\n  win.addEventListener('keyboardDidShow', ev => setKeyboardOpen(win, ev));\n  win.addEventListener('keyboardDidHide', () => setKeyboardClose(win));\n};\nconst setKeyboardOpen = (win, ev) => {\n  fireKeyboardOpenEvent(win, ev);\n  keyboardOpen = true;\n};\nconst setKeyboardClose = (win) => {\n  fireKeyboardCloseEvent(win);\n  keyboardOpen = false;\n};\n/**\n * Returns `true` if the `keyboardOpen` flag is not\n * set, the previous visual viewport width equal the current\n * visual viewport width, and if the scaled difference\n * of the previous visual viewport height minus the current\n * visual viewport height is greater than KEYBOARD_THRESHOLD\n *\n * We need to be able to accommodate users who have zooming\n * enabled in their browser (or have zoomed in manually) which\n * is why we take into account the current visual viewport's\n * scale value.\n */\nconst keyboardDidOpen = () => {\n  const scaledHeightDifference = (previousVisualViewport.height - currentVisualViewport.height) * currentVisualViewport.scale;\n  return (!keyboardOpen &&\n    previousVisualViewport.width === currentVisualViewport.width &&\n    scaledHeightDifference > KEYBOARD_THRESHOLD);\n};\n/**\n * Returns `true` if the keyboard is open,\n * but the keyboard did not close\n */\nconst keyboardDidResize = (win) => {\n  return keyboardOpen && !keyboardDidClose(win);\n};\n/**\n * Determine if the keyboard was closed\n * Returns `true` if the `keyboardOpen` flag is set and\n * the current visual viewport height equals the\n * layout viewport height.\n */\nconst keyboardDidClose = (win) => {\n  return keyboardOpen && currentVisualViewport.height === win.innerHeight;\n};\n/**\n * Dispatch a keyboard open event\n */\nconst fireKeyboardOpenEvent = (win, nativeEv) => {\n  const keyboardHeight = nativeEv ? nativeEv.keyboardHeight : win.innerHeight - currentVisualViewport.height;\n  const ev = new CustomEvent(KEYBOARD_DID_OPEN, {\n    detail: { keyboardHeight }\n  });\n  win.dispatchEvent(ev);\n};\n/**\n * Dispatch a keyboard close event\n */\nconst fireKeyboardCloseEvent = (win) => {\n  const ev = new CustomEvent(KEYBOARD_DID_CLOSE);\n  win.dispatchEvent(ev);\n};\n/**\n * Given a window object, create a copy of\n * the current visual and layout viewport states\n * while also preserving the previous visual and\n * layout viewport states\n */\nconst trackViewportChanges = (win) => {\n  previousVisualViewport = Object.assign({}, currentVisualViewport);\n  currentVisualViewport = copyVisualViewport(win.visualViewport);\n};\n/**\n * Creates a deep copy of the visual viewport\n * at a given state\n */\nconst copyVisualViewport = (visualViewport) => {\n  return {\n    width: Math.round(visualViewport.width),\n    height: Math.round(visualViewport.height),\n    offsetTop: visualViewport.offsetTop,\n    offsetLeft: visualViewport.offsetLeft,\n    pageTop: visualViewport.pageTop,\n    pageLeft: visualViewport.pageLeft,\n    scale: visualViewport.scale\n  };\n};\n\n\n\n\n/***/ })\n\n}]);","inputSourceMap":null}