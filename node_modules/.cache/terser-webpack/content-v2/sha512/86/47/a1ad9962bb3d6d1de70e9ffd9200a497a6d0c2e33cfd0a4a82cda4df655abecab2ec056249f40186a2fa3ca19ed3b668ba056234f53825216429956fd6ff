{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[64],{nGaW:function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,\"KEYBOARD_DID_CLOSE\",function(){return KEYBOARD_DID_CLOSE}),__webpack_require__.d(__webpack_exports__,\"KEYBOARD_DID_OPEN\",function(){return KEYBOARD_DID_OPEN}),__webpack_require__.d(__webpack_exports__,\"copyVisualViewport\",function(){return copyVisualViewport}),__webpack_require__.d(__webpack_exports__,\"keyboardDidClose\",function(){return keyboardDidClose}),__webpack_require__.d(__webpack_exports__,\"keyboardDidOpen\",function(){return keyboardDidOpen}),__webpack_require__.d(__webpack_exports__,\"keyboardDidResize\",function(){return keyboardDidResize}),__webpack_require__.d(__webpack_exports__,\"resetKeyboardAssist\",function(){return resetKeyboardAssist}),__webpack_require__.d(__webpack_exports__,\"setKeyboardClose\",function(){return setKeyboardClose}),__webpack_require__.d(__webpack_exports__,\"setKeyboardOpen\",function(){return setKeyboardOpen}),__webpack_require__.d(__webpack_exports__,\"startKeyboardAssist\",function(){return startKeyboardAssist}),__webpack_require__.d(__webpack_exports__,\"trackViewportChanges\",function(){return trackViewportChanges});const KEYBOARD_DID_OPEN=\"ionKeyboardDidShow\",KEYBOARD_DID_CLOSE=\"ionKeyboardDidHide\";let previousVisualViewport={},currentVisualViewport={},keyboardOpen=!1;const resetKeyboardAssist=()=>{previousVisualViewport={},currentVisualViewport={},keyboardOpen=!1},startKeyboardAssist=win=>{startNativeListeners(win),win.visualViewport&&(currentVisualViewport=copyVisualViewport(win.visualViewport),win.visualViewport.onresize=()=>{trackViewportChanges(win),keyboardDidOpen()||keyboardDidResize(win)?setKeyboardOpen(win):keyboardDidClose(win)&&setKeyboardClose(win)})},startNativeListeners=win=>{win.addEventListener(\"keyboardDidShow\",ev=>setKeyboardOpen(win,ev)),win.addEventListener(\"keyboardDidHide\",()=>setKeyboardClose(win))},setKeyboardOpen=(win,ev)=>{fireKeyboardOpenEvent(win,ev),keyboardOpen=!0},setKeyboardClose=win=>{fireKeyboardCloseEvent(win),keyboardOpen=!1},keyboardDidOpen=()=>!keyboardOpen&&previousVisualViewport.width===currentVisualViewport.width&&(previousVisualViewport.height-currentVisualViewport.height)*currentVisualViewport.scale>150,keyboardDidResize=win=>keyboardOpen&&!keyboardDidClose(win),keyboardDidClose=win=>keyboardOpen&&currentVisualViewport.height===win.innerHeight,fireKeyboardOpenEvent=(win,nativeEv)=>{const ev=new CustomEvent(KEYBOARD_DID_OPEN,{detail:{keyboardHeight:nativeEv?nativeEv.keyboardHeight:win.innerHeight-currentVisualViewport.height}});win.dispatchEvent(ev)},fireKeyboardCloseEvent=win=>{const ev=new CustomEvent(KEYBOARD_DID_CLOSE);win.dispatchEvent(ev)},trackViewportChanges=win=>{previousVisualViewport=Object.assign({},currentVisualViewport),currentVisualViewport=copyVisualViewport(win.visualViewport)},copyVisualViewport=visualViewport=>({width:Math.round(visualViewport.width),height:Math.round(visualViewport.height),offsetTop:visualViewport.offsetTop,offsetLeft:visualViewport.offsetLeft,pageTop:visualViewport.pageTop,pageLeft:visualViewport.pageLeft,scale:visualViewport.scale})}}]);","name":"64-es2015.6590a69f5ac971b6e706.js","input":"(window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || []).push([[64],{\n\n/***/ \"nGaW\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"KEYBOARD_DID_CLOSE\", function() { return KEYBOARD_DID_CLOSE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"KEYBOARD_DID_OPEN\", function() { return KEYBOARD_DID_OPEN; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"copyVisualViewport\", function() { return copyVisualViewport; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"keyboardDidClose\", function() { return keyboardDidClose; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"keyboardDidOpen\", function() { return keyboardDidOpen; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"keyboardDidResize\", function() { return keyboardDidResize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"resetKeyboardAssist\", function() { return resetKeyboardAssist; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setKeyboardClose\", function() { return setKeyboardClose; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setKeyboardOpen\", function() { return setKeyboardOpen; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"startKeyboardAssist\", function() { return startKeyboardAssist; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"trackViewportChanges\", function() { return trackViewportChanges; });\nconst KEYBOARD_DID_OPEN = 'ionKeyboardDidShow';\nconst KEYBOARD_DID_CLOSE = 'ionKeyboardDidHide';\nconst KEYBOARD_THRESHOLD = 150;\nlet previousVisualViewport = {};\nlet currentVisualViewport = {};\nlet keyboardOpen = false;\n/**\n * This is only used for tests\n */\nconst resetKeyboardAssist = () => {\n  previousVisualViewport = {};\n  currentVisualViewport = {};\n  keyboardOpen = false;\n};\nconst startKeyboardAssist = (win) => {\n  startNativeListeners(win);\n  if (!win.visualViewport) {\n    return;\n  }\n  currentVisualViewport = copyVisualViewport(win.visualViewport);\n  win.visualViewport.onresize = () => {\n    trackViewportChanges(win);\n    if (keyboardDidOpen() || keyboardDidResize(win)) {\n      setKeyboardOpen(win);\n    }\n    else if (keyboardDidClose(win)) {\n      setKeyboardClose(win);\n    }\n  };\n};\n/**\n * Listen for events fired by native keyboard plugin\n * in Capacitor/Cordova so devs only need to listen\n * in one place.\n */\nconst startNativeListeners = (win) => {\n  win.addEventListener('keyboardDidShow', ev => setKeyboardOpen(win, ev));\n  win.addEventListener('keyboardDidHide', () => setKeyboardClose(win));\n};\nconst setKeyboardOpen = (win, ev) => {\n  fireKeyboardOpenEvent(win, ev);\n  keyboardOpen = true;\n};\nconst setKeyboardClose = (win) => {\n  fireKeyboardCloseEvent(win);\n  keyboardOpen = false;\n};\n/**\n * Returns `true` if the `keyboardOpen` flag is not\n * set, the previous visual viewport width equal the current\n * visual viewport width, and if the scaled difference\n * of the previous visual viewport height minus the current\n * visual viewport height is greater than KEYBOARD_THRESHOLD\n *\n * We need to be able to accommodate users who have zooming\n * enabled in their browser (or have zoomed in manually) which\n * is why we take into account the current visual viewport's\n * scale value.\n */\nconst keyboardDidOpen = () => {\n  const scaledHeightDifference = (previousVisualViewport.height - currentVisualViewport.height) * currentVisualViewport.scale;\n  return (!keyboardOpen &&\n    previousVisualViewport.width === currentVisualViewport.width &&\n    scaledHeightDifference > KEYBOARD_THRESHOLD);\n};\n/**\n * Returns `true` if the keyboard is open,\n * but the keyboard did not close\n */\nconst keyboardDidResize = (win) => {\n  return keyboardOpen && !keyboardDidClose(win);\n};\n/**\n * Determine if the keyboard was closed\n * Returns `true` if the `keyboardOpen` flag is set and\n * the current visual viewport height equals the\n * layout viewport height.\n */\nconst keyboardDidClose = (win) => {\n  return keyboardOpen && currentVisualViewport.height === win.innerHeight;\n};\n/**\n * Dispatch a keyboard open event\n */\nconst fireKeyboardOpenEvent = (win, nativeEv) => {\n  const keyboardHeight = nativeEv ? nativeEv.keyboardHeight : win.innerHeight - currentVisualViewport.height;\n  const ev = new CustomEvent(KEYBOARD_DID_OPEN, {\n    detail: { keyboardHeight }\n  });\n  win.dispatchEvent(ev);\n};\n/**\n * Dispatch a keyboard close event\n */\nconst fireKeyboardCloseEvent = (win) => {\n  const ev = new CustomEvent(KEYBOARD_DID_CLOSE);\n  win.dispatchEvent(ev);\n};\n/**\n * Given a window object, create a copy of\n * the current visual and layout viewport states\n * while also preserving the previous visual and\n * layout viewport states\n */\nconst trackViewportChanges = (win) => {\n  previousVisualViewport = Object.assign({}, currentVisualViewport);\n  currentVisualViewport = copyVisualViewport(win.visualViewport);\n};\n/**\n * Creates a deep copy of the visual viewport\n * at a given state\n */\nconst copyVisualViewport = (visualViewport) => {\n  return {\n    width: Math.round(visualViewport.width),\n    height: Math.round(visualViewport.height),\n    offsetTop: visualViewport.offsetTop,\n    offsetLeft: visualViewport.offsetLeft,\n    pageTop: visualViewport.pageTop,\n    pageLeft: visualViewport.pageLeft,\n    scale: visualViewport.scale\n  };\n};\n\n\n\n\n/***/ })\n\n}]);","inputSourceMap":null}